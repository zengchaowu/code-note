# 作用域

## 编译

在 c 等静态语言中，作用域只在编译之前存在，在编译后就消失了。js 虽然是解释执行语言，但是在解释执行时，也需要与静态语言一样进行编译处理。主要的区别在于 js 作用域在运行时也是存在的，因为 js 是边解释边执行的。

下面简单介绍下编译过程：

1.  词法分析：将源代码分解为单个 token，也就是编译器能识别的最小单元，例如变量，常量，运算符等等。
2.  语法分析：将上面词法分析生成的词法单元数组转换成一颗抽象语法树。
3.  代码生成：将 AST 转换为可执行代码。

## 作用域

作用域的出现是为了减少变量冲突，从而实现模块的高内聚。其本身只是一套访问规则，在 js 语言中，引擎执行代码时，如果遇到某一个变量，会通过作用域进行查找，而作用域本身我们可以看作一个对象（无法被 js 获取），里面存储着上级作用域的指针和本级作用域的所有已声明的变量。

## es6 块作用域

js 在 es6 之前没有块作用域，在 es6 中补上了这一基本语法。之前只有函数、with 代码块，trycatch 中的 catch 代码块能创建作用域。

es6 之后通过 let,const 等可以创建块作用域。

## LHS 和 RHS

简单来说，引擎通过作用域查找变量时，出于不同的目的区分了 LHS 和 RHS。如果是取值则为 RHS，赋值则为 LHS，其主要区别为，在严格模式（ES5 引入 ）下，LHS 不会在未找到的变量时自动创建一个。

## js 的 with 代码块

with(obj) 代码块，可以用来将一个对象处理成一个词法作用域（创建一个新的）。它与空代码块（js 语言中使用较少）的区别是附加了一个作用域，并且这个作用域中包含了指定对象的所有属性标识符。

## 模块化与全局作用域

在模块化出现之前，所有在最外层声明的属性都会自动挂载到全局作用域，以实现多个文件之间共享。但是随着 js 规模增加，无法避免出现变量全局污染的问题，模块化则默认禁止将变量声明在全局作用域中。

## IIFE 规避作用域污染

如果我们需要一个作用域，并且尽可能避免污染外层作用域，由于 js 只有函数能创建作用域，我们必须使用匿名函数。而函数如果没有被调用，只有声明的话，其内部代码也不会被执行。但 js 提供了一种方式直接执行匿名函数 IIFE。

其有多种写法，通常以(function 开头。下面是比较常用的一种写法。

(function f(){})()

## 变量提升

js 在大部分情况下是一行一行执行的，但是在编译过程的语法分析阶段，存在一个将变量与对应作用域绑定的过程。这样，在运行时对变量进行查找才能通过作用域链找到。

这样就会有一个现象，变量声明可以出现在使用之后。并且，变量可以被反复声明，因为经历过变量提升后，只会存在一个有意义的提升。

```
console.log(a);
var a = 2;
```

在其他语言中，变量一般需要先声明再使用，js 的语法更特别一些。上面的语法，其实可以当作 var a 声明在编译时就已经完成了。console 和对 a 的赋值都在运行时才执行。所以这里 console 会输出 undefined，因为赋值语句还是在 console 之后执行的。

## 闭包

我们知道，作用域是在定义时就进行绑定的。在某些情况下，函数在其他作用域中执行仍然需要访问定义时的作用域，所以，函数不得不持有对定义时作用域的引用，这个函数就叫做闭包。

无论以何种方法，将内部函数传递到其定义所在的词法作用域之外，就会发生闭包。通常是在一个函数中返回一个内部函数。

## 什么时候产生闭包

1. 当内部函数访问其外部作用域的变量时
2. 当内部函数被返回并在其外部被引用时

此时，内部函数会持有外部作用域的引用，以便访问外部作用域的变量。即便函数此次执行完毕，外部作用域也不会被释放。

## 闭包内存泄漏

外部作用域不会被释放，如果外部作用域包含大量内存分配，则可能导致内存泄漏。

怎么解决泄漏问题？

1. 全局作用域中接收闭包函数的变量置为 null
2. 接收闭包函数的变量存在于局部作用域中则不需要处理。
