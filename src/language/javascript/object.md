# 对象

## 面相对象

面向对象出现之初，是为了使用对象模拟现实中存在的事物。人们将一个事物抽象成两个部分，属性存储数据，方法提供功能。所以在编程语言中，一个既能包含属性，也能包含方法的复杂数据类型就可以用来存储对象。

## js 的面相对象

js 语言中，对象基于原型链实现继承等功能。

基本所有非内置的函数都有一个 prototype 属性，内置的构造函数也有，用来存放其原型对象，箭头函数和 Function.prototype.bind 创建的函数没有。

所有的对象都存在一个\_\_proto\_\_属性，称为隐式原型，指向构造函数的原型对象。在查找属性或者方法时，如果在对象本身没有找到，会通过原型链递归查找，原型链的终点一般是 Object.prototype 对象。

for in 会遍历原型链。使用`var dic = Object.create(null)`创建一个没有原型链的对象，更方便数据的存储。

## 函数和构造函数调用

函数本身只是一段代码的集合，js 中并没有构造函数，但是为了模拟面相对象，可以用类似构造函数的方式去调用一个普通函数从而生成一个对象。这个方式就叫做构造函数调用。

`new fn()`就是一个构造函数调用，它比普通函数调用多了几个步骤。

1. 首先创建一个空对象
2. 将新对象的\_\_proto\_\_指向 fn 函数的 prototype
3. 将这个函数中的 this 绑定为这个新对象
4. 执行 fn 函数
5. 返回这个对象

## this 问题

在其他语言中，this 存在于对象中，并且始终指向该对象本身，一般在编译时，就会对 this 进行绑定。

但在 js 中，this 是在调用时被绑定的，指向的是调用此函数的对象。

### 默认绑定

在严格模式下，普通函数中 this 会被绑定为 undefined，非严格模式则为全局对象 windows 或者 gloabal。因为非严格模式，所有变量和函数都会自动挂载到全局对象上，调用函数则相当于全局对象调用的。

## instanceof 和 typeof

## mixin 混入

混入提供了类似继承的功能，但是其实是相当于将两个对象合并为一个对象。更像是一种组合方式。
