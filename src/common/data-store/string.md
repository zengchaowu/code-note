字符串，最基本的变长类型。

## 字符与编码

计算机只能存储数字，那么应该怎么存储一个英文字母或者汉字呢。最简单的办法，就是给每一个英文字母或者汉字都指定一个对应的数字，这个对应关系就是编码表。

计算机底层最常见的编码表是ASCII编码，这个编码表总共定义了128个字符和数字的对应关系，包含了英语的26个字母和大部分键盘上能看到的字符。既然字符在硬盘上存储的也是数字，那我们怎么确定存储在硬盘上的数字代表的是一个字符还是就是一个数字呢。答案是通过类型，在c语言中，一个数字使用int类型赋值则为数字，使用char类型赋值则为ASCII字符。

需要注意的是，在不同的语言中，char类型所占用的长度并不同，因为不同语言使用的编码表不同。在c系列语言中为1个字节，因为使用的是ASCII，在java则为2个字节，因为使用的是unicode编码。

### 什么是unicode
上面我们介绍了ASCII编码表，通过约定char类型的编码表为ASCII，我们能够实现英文字母和部分常见字符的存储和取出。但是，我们无法存储汉字，因为ASCII上面并没有汉字对应数字的对应关系。

因此，我们需要有一个表，上面将所有语言的所有字都对应一个数字，这个表就是unicode表。语言是不断在变化和拓展的，所以unicode表也在一直更新中，截至2023年，最新版本为15.0版本，其规模有十五万个左右的字符，其中包含大量的emoji表情字符。

[unicode官网](https://home.unicode.org)

因为ASCII编码表是固定的，存储128个字符的最小内存单元就是一个字节。所以，采用ASCII编码作为字符编码方式的语言中，一个字符都只占用一个字节。但是，如果一个语言采用unicode编码存储字符，它的字符会占用多大的空间呢？

### 什么是编码空间
由于码表在不断的变大，所以我们需要先约定一个字符对应数字也就是码点的范围，这个范围必须大于现在已经编码的字符的总数，并且还需要考虑到字符不断增长的情况，这个约定的范围就是编码空间。由于ASCII码表是不变的，所以它的编码空间是一个字节。但是unicode编码是一直在变化的，所以编码空间与其版本有关。

现行的unicode版本，将编码空间划分为17个部分。第一部分范围为0-65535，第二部分范围为65536-131071，第十七部分为1048576-1114111，所有最常见的字符都放在第一个范围内（常见汉字在第一部分，生僻字则不在第一部分），unicode最早的编码空间也就是第一个范围，后续随着编码表的变大，才拓展成现在的17个部分。所以，如果我们只需要支持常见字符的话，使用两个字节来存储字符即可。要将前面说的十七个部分都存起来需要21位，也就是三个字节。

### UCS
unicode编码由统一码联盟定义，但是不是官方的标准。国际标准化组织定义的编码规范为UCS。现在的版本中，两个编码是兼容的，但是UCS有31位的编码空间，也就是需要4个字节，与unicode重叠的21位编码空间内的字符码点对应关系是相同的。

## UTF

我们现在已经知道，所有字符都可以通过unicode编码表查找到对应的数字，然后以数字的方式存储到内存中。这个数字怎么存储，现在流行的有两种处理方式。

### 1. 定长存储
字符的码点，直接使用数字的方式存储，不经过任何转换。每个字符都分配一样的空间，如果采用unicode并且想支持所有21位编码空间，则所有字符都使用3个字节来存储。采用UCS并希望支持所有31位编码空间，则所有字符都使用4个字节来存储。如utf-32/UCS-4就是如此，所有字符都使用32位存储，并且码点也不会进行任何拆分就直接存储到这32位空间中。

这种方式是最简单的，但是存在一个很大的问题，就是英语和常见字都只占用1到2个字节，也就是说，他们的数字通常小于65535，但是却分配了三个或者四个字节的空间，这样的话，绝大部分字符高位都会存在大量的补0。这种存储方式对内存和带宽都造成严重浪费，一定程度上阻碍了unicode编码表的推广。

![utf32](./assets/utf32.png)

### 2. 变长存储
将一个整数拆分成多个字节进行存储，并且约定每个字节前面几位拥有特殊含义。这样，通过单个字节前面的位，就可以找到所有的被拆分出来的字节，计算出本来的码点然后通过unicode编码表找到对应的字符。

### UTF-8
utf-8是现在使用最广泛的码点转换算法，它的规则如下：

#### 1. 拆分出来的第一个字节前面的前缀码用来标识这个码点拆分的字节数。
例如：如果码点拆分成三个字节，则这三个字节的第一个字节的前缀码为1110，也就是说，第一个字节只有4位有效位了。两个的前缀码则为110，一个的情况比较特殊，为了兼容ascii编码表的所有字符，如果目标字节为一个字节，那这个字节的前缀码为0。

#### 2. 拆分出来的第二个字节开始前缀码均为10
例如：如果码点被拆分成两个字节，则这个码点实际存储为 110xxxxx 10xxxxxx 。

#### 空间占用
由于前缀码的存在，所以单字节的有效位为7，双字节的有效位为11，三字节的有效位为16，四字节的有效位为21。我们上面提到了，unicode现在的编码空间就是21位，所以，通过utf-8的码点转换算法，unicode字符最多会占用4个字节的空间。

### UTF-16
前面我们说过，我们所有的常用字都放在unicode的第一个部分，但是生僻字会放在其他部分。utf-16的规则很简单，如果码点是第一部分范围内，则使用两个字节存储。如果不是第一部分则使用4个字节存储。这种编码方法在基本都是常见字符的情况下有较好的性能，目前JVM采用的就是UTF16作为unicode码点存储方式。

#### 如何区分是两字节还是四字节
在unicode第一部分，从U+D800到U+DFFF是一个空段，即这些码点不对应任何字符。利用这些特殊的码点，我们可以让程序区分是两字节还是四字节。

首先，unicode除去第一部分，还有2^20个字符，也就是这些超出范围的字符需要20位来存储。那么，怎么从四个字节中找到20个有效位并且标识出这是个四字节码点呢。我们将这个20位的码点拆成两个10位的，前面两个字节放高位的10位，后面两个字节放低位的10位，并且让前面两个字节和后面两个字节对应的码点，都在U+D800到U+DFFF这个空段间的，这样，通过码点就知道是不是四字节的字符了。

怎么让前后10位都落在空段码点呢，因为两个字节占用16位，我们只需要将需要存储的10位覆盖这个16位空段的后面10位，就能保证合成后的码点一定在空段内了。我们需要取出时，只取后面10位即可。

如果我们可以让前面两个字节的码点范围和后面两个字节的码点范围的前面6位不同，那我们通过判断前面6位就能快速知道这两个字节是前面两个字节还是后面两个字节。这也是utf-16高10位和低10位覆盖的目标不同的原因。这样前两个字节就肯定是110110开头，后面两个字节肯定以110111开头。

如下演示一个中文问号的计算过程

![utf16](./assets/utf16.png)

## 字符串

