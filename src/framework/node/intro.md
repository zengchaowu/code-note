## 渲染引擎

渲染引擎的作用是解析HTML和CSS文档，构建DOM树和CSSOM树，将它们合并成渲染树，然后进行页面布局和绘制的计算，最终得到的是一份描述页面布局和样式的渲染树。这份渲染树并不是一个真实的图像，它只是一个描述页面元素如何排列组合的树状结构。最终的绘制和显示是由浏览器另外一个组件UI后端来完成的，它将渲染树转换成实际的像素图像，并将它显示在屏幕上。

### 引擎种类

1. blink：它是 WebKit 引擎的一个分支。Blink 引擎主要用于 Google Chrome 和其他 Chromium 系浏览器。安卓系统上通常使用此引擎，腾讯x5也是基于blink。但是一些第三方浏览器也会使用webkit引擎。安卓4.4版本后的系统的webview api也是基于blink。
2. WebKit：WebKit 是最早的浏览器渲染引擎之一，最初由苹果公司开发，后来成为开源项目。目前主要用于 Safari 浏览器和一些基于 WebKit 的浏览器。iOS系统强制使用此引擎。
3. Trident：Trident 是由微软开发的浏览器渲染引擎，主要用于 Internet Explorer 浏览器。

## js引擎

js引擎的主要作用是解析和执行JavaScript代码。如果没有js引擎，浏览器就只能通过html和css实现静态网页。

### 引擎种类

1. v8引擎，用于chrome和node，安卓手机4.4之后系统webview使用的是此引擎。
2. JavaScriptCore，用于safari和webkit，苹果手机强制使用此引擎。
3. Chakra，主要用于ie。

### Dom和Bom

浏览器解析HTML文档时，它会根据文档的结构创建DOM树，然后将DOM树暴露给JavaScript引擎。

JavaScript引擎将DOM树封装在全局对象window下的Document对象中。开发者可以使用JavaScript中的Document对象和其他相关的API来访问和操作DOM树。

BOM（Browser Object Model）是由浏览器提供的JavaScript API集合，用于控制浏览器窗口和与浏览器交互的对象。通常包括下面几个部分：

1. Window对象：代表浏览器窗口，并提供了操作浏览器窗口的API，例如打开、关闭、移动、调整大小等。
2. Location对象：代表当前文档的URL，并提供了API来获取和设置URL的不同部分，例如主机、路径、哈希等。
3. Navigator对象：提供了有关浏览器的信息，例如浏览器的名称、版本、平台、语言等。
4. Screen对象：提供了有关用户屏幕的信息，例如屏幕分辨率、可用高度、可用宽度等。
5. History对象：提供了访问浏览器历史记录的API，例如后退、前进、刷新等。
6. Document对象：代表当前文档，并提供了操作文档内容的API，例如获取、创建、修改、删除元素等。

## node与浏览器的区别

1. node只是基于v8JS引擎进行包装，所以不存在渲染引擎。
2. node运行于主机上，提供了文件和操作系统的api，但是没有dom和bom对象。
3. nodejs能够完全控制整台设备，而浏览器中的js则被js引擎限制在一定的安全范围内。
4. node是单线程的，但是可以创建子进程。

## 单线程模型

单线程模型（Single-threaded model）是一种程序执行模型，其中只有一个线程（thread）来处理所有的任务和操作。在这种模型下，所有的任务和操作都是依次执行的，因此每个操作必须等待前一个操作执行完成后才能开始执行。

单线程模型通常用于处理事件驱动的程序，例如 Web 应用程序。在 Web 应用程序中，用户请求通常是通过一个线程来处理的，每个请求都是按顺序依次处理的。如果有一个请求需要执行耗时的操作，例如读取文件或者访问数据库等，那么这个请求将会阻塞线程的执行，从而影响其他请求的处理和响应时间。

为了避免这种情况，单线程模型通常会采用异步编程模型，即将耗时的操作委托给其他线程或者进程来处理，而不是阻塞当前的线程。在异步编程模型中，当前线程可以继续处理其他请求或者操作，等待耗时操作的结果返回后再继续执行相应的处理逻辑。

需要注意的是，单线程模型并不一定意味着只有一个线程在程序中运行。在某些情况下，程序可能会启动多个线程或进程来处理不同的任务或操作，但这些线程或进程通常是在单个线程的上下文中运行的，它们之间需要进行同步和通信，以确保整个程序的正确执行。

### nodejs

Node.js 是一种单线程模型的编程语言和运行环境。在 Node.js 中，只有一个主线程来处理所有的任务和操作，例如网络请求、文件操作等等。这个主线程会通过事件循环（Event Loop）机制来处理异步任务和事件回调，以确保整个程序的正确执行。

需要注意的是，虽然 Node.js 是单线程模型的，但是在底层实现中，它使用了多线程和事件驱动机制来处理网络和文件 I/O，以及其他一些耗时操作。这些线程和事件都是在 Node.js 的内部处理的，对开发人员是透明的。

## 异步io与事件循环

libuv是一个跨平台的异步I/O库，它提供了事件循环、非阻塞I/O等功能。Node.js使用了libuv来处理底层I/O操作和事件循环。

**同步io**

几乎所有的传统服务器端编程语言都采用阻塞 I/O 模型，这些语言在执行 I/O 操作时会阻塞当前线程或进程，直到 I/O 操作完成并返回结果，这会导致线程的资源被浪费，同时也会限制系统的并发性能和吞吐量。

**解决阻塞**

把 I/O 操作放在最后执行，其实也是一种避免阻塞的策略。但是这种策略需要程序员手动管理任务的执行顺序，而且代码可读性较差。

或者可以将io操作放在单独的线程，但是，使用多线程模型存在线程切换和锁竞争等问题，会带来一些额外的开销，而且需要手动管理线程的创建和销毁。

**异步io**

在异步 I/O 模型中，当应用程序执行 I/O 操作时，操作系统不会阻塞应用程序，而是立即返回一个结果，告诉应用程序 I/O 操作已经开始了。应用程序可以在 I/O 操作完成后通过回调函数来获取结果。异步 I/O 模型不是说线程不需要等待 I/O 操作完成，而是在线程等待的过程中可以执行其他的任务。


### 事件循环

nodejs默认只会开启一个线程处理js，这个线程负责事件循环、I/O 操作和回调函数的执行，执行完同步代码后，就会进入事件循环。

**主要阶段**

事件循环每一轮大概有六个阶段，大部分阶段都存在一个或多个队列，这些队列都是宏任务队列。微任务队列只有两个，一个是nexttick队列，一个是其他微任务队列，在每个阶段切换时，会先清空nexttick，再清空其他微任务队列。

1. timers：检查是否有定时器过期，处理 setTimeout 和 setInterval 设置的过期的定时器回调函数。
2. pending callbacks：处理某些系统操作的回调函数，例如 TCP 套接字的错误处理函数。
3. idle, prepare：仅在内部使用。
4. poll：处理除了定时器和系统操作回调函数以外的所有 I/O 相关的回调函数。在进入 poll 阶段后，清空poll阶段的io队列后，会先检查是否有定时器到期或者 setImmediate 函数设置的回调函数需要执行，如果有，则进入 timers 阶段或者 check 阶段执行相应的回调函数。如果没有，则会阻塞在 poll 阶段等待新的事件的到来。阻塞时，也会去检查是否有定时器过期，如果检查到有过期的定时器，则在清空当前poll阶段的io队列后跳转到timer阶段。
5. check：处理 setImmediate 函数设置的回调函数。
6. close callbacks：处理一些资源的关闭相关的回调函数，例如 TCP 套接字的 close 事件。

**定时器堆**

执行到定时器代码时会立刻将定时器加入到定时器观察者（timer watcher）中，但是它们不会立即被添加到定时器队列中。相反，它们将被添加到一个称为“timer heap”的内部数据结构中。定时器堆是一个二叉堆，用于维护所有定时器的按照剩余时间从小到大排序的顺序。当事件循环进入timer阶段时，将检查所有已经过期的定时器并将它们移动到timer队列中，以便在该阶段执行相关的回调函数。


**事件**

Node.js 中的事件循环机制通过 Event Emitter 模块来实现。在 Node.js 中，很多模块都继承了 Event Emitter 模块，比如 HTTP、Net、FS 等模块，这些模块会在适当的时候触发事件，将事件加入事件队列中。当事件队列中有事件时，事件循环会取出事件并执行相应的回调函数。

