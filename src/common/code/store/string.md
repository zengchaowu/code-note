---
title: 字符串
---

字符串，人类与计算机的桥梁。

## 实现原理

字符在计算机内部会被以一个数字进行存储，字符串则通常被表示为字符的数组或者类似于数组的数据结构。

字符串的实现原理与编程语言、操作系统以及计算机硬件都有关系。通常有如下几种实现方式：

1. 零终止字符串（null-terminated string）：在 C 语言中，字符串通常是以 null 字符 '\0' 结尾的字符数组。在访问字符串时，需要遍历整个字符数组，直到找到 null 字符才能确定字符串的结束位置。
2. 长度前缀字符串（length-prefixed string）：这种实现方式将字符串的长度保存在字符串的开头，然后在字符串末尾添加 null 字符。在访问字符串时，可以直接从字符串开头读取字符串长度，从而确定字符串的结束位置。
3. Unicode 字符串：这种实现方式将字符编码从 ASCII 扩展到了 Unicode，支持更多的字符集和语言。在实现上，Unicode 字符串通常会将一个字符表示为一个或多个字节的编码序列，以便在计算机中存储和传输。
4. Rope（即“绳”）：这种实现方式将字符串表示为一个二叉树结构，其中每个节点包含一个子字符串和其长度。这种实现方式可以在执行字符串连接等操作时避免频繁的内存分配和移动，从而提高字符串操作的效率。
5. 哈希表：在某些情况下，使用哈希表可以提高字符串查找和比较的效率。哈希表将字符串映射到一个整数值，从而可以在常数时间内完成字符串的查找和比较操作。

## 字符串常量

字符串常量（string constant）是指在程序代码中直接出现的字符串值，也被称为字符串字面量（string literal）或字符串字面常量（string literal constant）。字符串常量通常被用作程序中的数据或者消息，字符串常量存储在常量区，地址在编译时就确定了，并被直接编码到可执行文件中，在程序运行时保持不变。

## 不可变字符串和可变字符串

**不可变字符串**

指创建后不可修改的字符串，即一旦字符串被创建，其中的字符就不能被修改。在不可变字符串中，任何修改操作都会返回一个新的字符串对象。在许多编程语言中，字符串都是不可变的，例如 Python、Java、Ruby 等。

不可变字符串在内存中通常是一段连续的内存空间，类似于 c 语言的字符数组。部分面相对象语言中，不可变字符串对象中除了包含这个字符数组的指针外，还有字符串的一些其他信息，例如长度。

**不可变的数据结构通常有一些线程安全和性能的优势，因为对其读取不需要加锁。**

**可变字符串**

可变字符串是指在创建后可以被修改的字符串，即其中的字符可以被替换、删除或添加。在可变字符串中，任何修改操作都是原地进行的，不需要返回一个新的字符串对象。在某些编程语言中，如 C++ 中的 std::string 类型和 Python 中的 bytearray 类型，字符串是可变的。

可变字符串的内存布局通常也是一个连续的字节序列，其中每个字节都代表一个字符，字节序列的末尾以 null 终止符结尾。与不可变字符串不同的是，可变字符串的长度可以在运行时动态增长或缩小，因此其内存布局也可以随之发生变化。以 C++ 中的 std::string 类型为例，当 std::string 对象需要进行修改操作时，它会重新分配字符数组的内存空间，以适应新的字符串长度，然后将原有的字符串数据复制到新的内存空间中。

**可变字符串的线程安全**

上面我们提到，可变字符串默认是线程不安全的，以 java 为例，StringBuilder 是线程不安全的，而 StringBuffer 是线程安全的。其实现方式是，为 StringBuffer 对象的每个方法声明为 synchronized。简单来说，java 中 synchronized 关键字的可以保证同一时间只有一个线程可以访问同步方法或**同步代码块**，其他线程需要等待当前线程释放锁之后才能继续执行。加锁的成本是很高的，所有对可变字符串的访问效率不高。

## 正则

字符串的使用中，除了基本的分割、连接等操作外，使用的最多的是正则查找。正则的模式匹配中，使用到了有限状态机。有限状态机也常用于源代码的编译。

### 有限状态机

是表示有限个状态以及在这些状态之间的转移和动作等行为的数学计算模型

状态机中有几个术语：state(状态) 、transition(转移) 、action(动作) 、transition condition(转移条件) 。

1. state(状态) ：将一个系统离散化，可以得到很多种状态，当然这些状态是有限的。例如：门禁闸机可以划分为开启状态、关闭状态；电扇可以划分为关、一档、二档、三档等状态。
2. transition(转移) ：一个状态接收一个输入执行了某些动作到达了另外一个状态的过程就是一个 transition(转移)。定义 transition(转移)就是在定义状态机的转移流程。
3. transition condition(转移条件) ：也叫做 Event(事件)，在某一状态下，只有达到了 transition condition(转移条件)，才会按照状态机的转移流程转移到下一状态，并执行相应的动作。
4. action(动作)：在状态机的运转过程中会有很多种动作。如：进入动作(entry action)[在进入状态时进行]、退出动作(exit action)[在退出状态时进行]、转移动作[在进行特定转移时进行]。

### 正则的匹配

其基本实现思路为：

1. 将正则表达式编译成一个匹配模式。在这个过程中，正则表达式会被解析并转换成一组匹配规则，用来描述待匹配字符串的模式。
2. 从目标字符串的起始位置开始匹配。在匹配的过程中，匹配引擎会逐个字符地扫描待匹配的字符串，然后对这些字符进行匹配。
3. 对于每个字符，匹配引擎会尝试将其与正则表达式的匹配规则进行匹配。如果匹配成功，则匹配引擎会继续匹配下一个字符，否则匹配引擎会回溯到前一个位置，尝试其他的匹配方式，也可以同时进行多个类似模式的匹配提高效率。
4. 如果匹配成功，则返回匹配结果，否则继续扫描字符串，直到扫描结束或者找到了匹配结果。

#### 贪婪和非贪婪

贪婪匹配和非贪婪匹配是正则表达式中常用的两种匹配方式，它们用来控制匹配的方式，从而影响匹配的结果。

贪婪匹配是指正则表达式尽可能多地匹配目标字符串，而非贪婪匹配则是尽可能少地匹配目标字符串。

例如，对于字符串 "abcabc"，正则表达式 "ab.c" 是贪婪匹配，会匹配整个字符串，而正则表达式 "ab.?c" 是非贪婪匹配，只会匹配 "abc"。

贪婪匹配是默认的匹配方式，可以通过在正则表达式中使用 "?" 来切换到非贪婪匹配。例如，使用 ".?" 来代替 "."，使用 "+?" 来代替 "+"，使用 "??", "{n,m}?" 等来代替 "{n,m}"。

需要注意的是，在匹配规则中使用非贪婪匹配可能会降低匹配效率，因为需要对每个可能的匹配结果都进行尝试。因此，在实际使用中应该根据具体情况选择合适的匹配方式。

#### 高级用法

**捕获组与非捕获组**

捕获组可以把匹配的部分单独提取出来，方便后续的处理。在正则表达式中，用圆括号将需要捕获的部分括起来即可。

例如，对于字符串 "2023-02-17"，可以使用正则表达式 "(\d{4})-(\d{2})-(\d{2})" 来捕获年、月、日。

非捕获组和捕获组类似，但不会将匹配的结果保存到内存中，也不会在匹配结果中返回。非捕获组的语法为 "(?:pattern)"。

例如，对于字符串 "a1b2c3"，可以使用正则表达式 "(?:[a-z]\d)+" 来匹配所有的字母数字组合，这里使用了非捕获组。

**后向引用**

后向引用是指在正则表达式中使用之前匹配的结果作为后续匹配的条件。后向引用通常与捕获组一起使用。

例如，对于字符串 "123 456 789"，可以使用正则表达式 "(\d+) \1" 来匹配连续的重复数字，这里使用了捕获组和后向引用。

**零宽断言**

零宽断言是一种特殊的匹配模式，它可以指定一个位置，而不是一个具体的字符，用来限定匹配的条件。常用的零宽断言包括：

- 正向先行断言（positive lookahead assertion）：表示后面的内容必须匹配指定的表达式，但不包括在匹配结果中，语法为 "(?=pattern)"。
- 负向先行断言（negative lookahead assertion）：表示后面的内容必须不匹配指定的表达式，语法为 "(?!pattern)"。
- 正向后行断言（positive lookbehind assertion）：表示前面的内容必须匹配指定的表达式，但不包括在匹配结果中，语法为 "(?<=pattern)"。
- 负向后行断言（negative lookbehind assertion）：表示前面的内容必须不匹配指定的表达式，语法为 "(?<!pattern)"。

例如，对于字符串 "hello, world"，可以使用正则表达式 "(?<=hello, )\w+" 来匹配 "world"，这里使用了正向后行断言来限定前面必须匹配 "hello, "。

**处理多行文本**

默认情况下，正则表达式只能处理单行文本。如果需要处理多行文本，需要在正则表达式中使用标记（flag）。常用的标记包括：

Pattern.MULTILINE：多行模式，表示^和$匹配每行的开头和结尾。
Pattern.DOTALL：点任意匹配模式，表示.可以匹配任意字符，包括换行符。
Pattern.UNICODE_CASE：Unicode大小写不敏感模式，表示大小写匹配时忽略Unicode字符集的大小写差异。
例如，对于字符串 "hello\nworld"，可以使用正则表达式 "^h.$" 来匹配第一行的 "hello"，如果需要匹配所有行的开头，需要使用多行模式，即使用 "(?m)^h.$" 来匹配所有的以 "h" 开头的行。
