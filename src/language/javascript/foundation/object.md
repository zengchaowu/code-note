# 对象

## 面相对象

面向对象出现之初，是为了使用对象模拟现实中存在的事物。人们将一个事物抽象成两个部分，属性存储数据，方法提供功能。所以在编程语言中，一个既能包含属性，也能包含方法的复杂数据类型就可以用来存储对象。

## js 的面相对象

js 语言中，对象基于原型链实现继承等功能。

基本所有非内置的函数都有一个 prototype 属性，内置的构造函数也有，用来存放其原型对象，箭头函数和 Function.prototype.bind 创建的函数没有。

所有的对象都存在一个\_\_proto\_\_属性，称为隐式原型，指向构造函数的原型对象。在查找属性或者方法时，如果在对象本身没有找到，会通过原型链递归查找，原型链的终点一般是 Object.prototype 对象。

for in 会遍历原型链。使用`var dic = Object.create(null)`创建一个没有原型链的对象，更方便数据的存储。

## 函数和构造函数调用

函数本身只是一段代码的集合，es6 之前 js 中并没有构造函数，但是为了模拟面相对象，可以用类似构造函数的方式去调用一个普通函数从而生成一个对象。这个方式就叫做构造函数调用。

`new fn()`就是一个构造函数调用，它比普通函数调用多了几个步骤。

1. 首先创建一个空对象
2. 将新对象的\_\_proto\_\_指向 fn 函数的 prototype
3. 将这个函数中的 this 绑定为这个新对象
4. 执行 fn 函数
5. 返回这个对象

## es6 的构造函数

在 es6 中，构造函数必须被命名为 constructor，我们必须使用 constructor 方法来初始化对象的属性。constructor 方法是 class 中特殊的一个方法，它会在使用 new 关键字创建对象时被调用。

这种写法已经与其他面向对面语言类似，主要的区别是 js 中没有析构函数。并且 js 中 constructor 还有返回值，这让我们 new 一个对象时，可以返回一个另外的对象。

**继承中的构造函数**

在子类中定义构造函数时，必须首先调用 super() 方法来调用父类的构造函数，并且必须在使用 this 关键字之前调用 super()。。super 关键字也可以用于其他被覆盖的子类方法中，用来调用父类方法和父类属性。

**super 的原理**

在子类中访问父类的原型方法时，可以使用 super.methodName() 的语法来调用，而 super 本质上是 Object.getPrototypeOf(this) 的简写。这意味着 super 实际上是访问了父类的原型对象，然后调用了该对象上的方法。

在子类的构造函数中调用父类的构造函数时，可以使用 super() 的语法来调用，而 super 实际上是将 this 绑定到父类的实例上，并调用父类的构造函数。这意味着 super() 实际上是调用了父类的构造函数，并传递了子类的实例作为参数。

## this 问题

在其他静态语言中，编译时，就会对 this 进行绑定。但在 js 中，this 是在调用时被绑定的，指向的是调用此函数的对象。this 的绑定有以下几种情况：

### 隐式绑定

通过函数调用中的上下文对象来绑定 this。例如，当函数作为对象的方法被调用时，this 就指向该对象。

### 显式绑定

使用 call()、apply() 或 bind() 函数显式地指定函数执行时的上下文对象，即 this。call 和 apply 都是用来改变函数的执行上下文，即函数内部的 this 关键字指向的对象。它们的区别在于传递参数的方式不同。call 方法的参数是一个一个地传递，而 apply 方法的参数是以数组的形式传递。bind 方法与 call 和 apply 的区别在于它不会立即调用函数，而是返回一个新的函数。新的函数的 this 关键字指向 bind 方法的第一个参数，并且可以传递额外的参数作为新函数的参数。

### new 绑定

在使用 new 操作符创建对象时，JavaScript 会将新对象的 this 绑定到构造函数中的 this。

### 箭头函数绑定

箭头函数中的 this 指向函数定义时所在的作用域，而不是函数执行时的上下文对象。这种方式也称为词法绑定。

### 默认绑定

在函数调用中没有明确指定 this 绑定对象时，this 会默认绑定到全局对象，在浏览器环境中是 window 对象，在 Node.js 环境中是 global 对象。在严格模式下，普通函数中 this 会被绑定为 undefined。

## instanceof 和 typeof

instanceof 用于判断一个对象是否属于某个类或构造函数的实例，只能用于判断对象类型，不能用于判断基本数据类型（如字符串、数字和布尔值）的类型。其原理是通过判断对象的原型链中是否存在指定的构造函数（或其原型对象），来确定对象是否属于该构造函数的实例。具体来说，instanceof 运算符会检查左侧的对象的原型链中是否存在右侧的构造函数（或其原型对象）。如果存在，就返回 true，否则返回 false。

typeof 运算符的原理是获取一个值的数据类型。它返回一个字符串，表示该值的类型。

## mixin 混入

混入（mixin）是指将一个对象的属性和方法合并到另一个对象中，以便该对象可以使用来自多个来源的行为。在 JavaScript 中，这个复制行为可以有多种实现方式，Object.assign，for...in 等。

**混入的缺点**

混入进行的是浅拷贝，如果源对象中的属性是引用类型，那么复制到目标对象中的属性值是该引用的副本。因此，如果修改源对象中的引用类型属性，则可能会影响到目标对象中对应属性的值。

我们在使用混入时，最好被混入的对象是无状态的，这样才能避免被混入对象被多个对象混入时导致修改难以追踪。

**vue 中的混入**

Vue 中的混入（Mixin）是一种可复用 Vue 组件中常见的技术。它允许我们将一组属性、方法或生命周期钩子等组合成一个可复用的对象，并将其混合到多个 Vue 组件中。混入在 Vue 中的实现非常简单，可以通过在组件中使用 mixins 属性来实现。

需要注意的是，混入会将混入对象中的属性和方法与组件中的属性和方法进行合并，如果混入对象和组件中的属性或方法名冲突，组件本身的优先级更高，则会覆盖混入对象中的属性或方法。因此，在使用混入时，需要特别注意命名冲突问题。

vue 中混入的规则如下：

1. 数据对象的合并策略：如果两个组件中的数据对象有同名属性，则会进行浅合并，组件中的属性会覆盖混入对象中的属性。
2. 钩子函数的合并策略：如果两个组件都定义了相同的钩子函数，那么这些函数将被依次调用。在调用钩子函数时，混入对象的函数会先被调用，然后是组件中定义的函数。
3. 其他选项的合并策略：其他选项如 methods、computed、watch 等，都会被合并到组件选项中，冲突处理与数据对象相同。
